using Core.Factories;
using Core.Helpers;
using Core.Interface;
using Core.Services;
using Infrastructure.Interfaces;
using Infrastructure.Services;
using Microsoft.Extensions.DependencyInjection;
using Nexus.Helpers;
using Nexus.Interfaces;
using Nexus.Services;
using Nexus.Views;

namespace Nexus;

internal static class Program
{
    /// <summary>
    /// Main entry point for the application.
    /// Using async Task Main() to support async Main method
    /// </summary>
    private static async Task Main()
    {
        // Setting Upp Dependency Injection DI
        // https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-usage
        // https://www.c-sharpcorner.com/article/using-dependency-injection-in-net-console-apps/
        var services = new ServiceCollection();
        ConfigureServices(services);

        // Let's build the service Provider
        var serviceProvider = services.BuildServiceProvider();

        // Now we can get the HomeView and run it
        var homeView = serviceProvider.GetRequiredService<IHomeView>();
        await homeView.Run();
    }
    // https://stackoverflow.com/questions/32459670/resolving-instances-with-asp-net-core-di-from-within-configureservices
    // IServiceCollection interface is used for building our dependency injection container

    /// <summary>
    /// Demonstrates registration of a service that implements multiple interfaces using dependency injection.
    /// This pattern supports Interface Segregation Principle (ISP) while maintaining singleton instance state.
    ///
    /// This was documentation/Summary was generated by Phind AI and got assisted to extend the code
    /// to support the Interface Segregation Principle (ISP) while maintaining singleton instance state.
    ///
    /// </summary>
    /// <remarks>
    /// Key concepts:
    /// 1. Register concrete service first to maintain single instance
    /// 2. Map interfaces to the concrete instance using lambda expressions
    /// 3. Use GetRequiredService to ensure the same instance is used across interfaces
    ///
    /// Implementation Steps:
    /// 1. Create segregated interfaces for different responsibilities (e.g., IMenuCreateService, IGetMenuService)
    /// 2. Implement these interfaces in a single service class (e.g., MenuService)
    /// 3. Register the concrete service first using AddSingleton
    /// 4. Map each interface to the same service instance using lambda expressions
    ///
    /// Benefits:
    /// - Maintains single instance state across all interface implementations
    /// - Supports Interface Segregation Principle
    /// - Allows for clean dependency injection by specific interfaces
    /// - Preserves service state when accessed through different interfaces
    /// - Enables better unit testing through segregated interfaces
    /// </remarks>
    private static void ConfigureServices(IServiceCollection services)
    {
        // Registering we are using AddSingleton when we need a single state
        // We want to maintain our state a cross our application
        services.AddSingleton<IHomeView, HomeView>();
        services.AddSingleton<IShowContacts, ShowContacts>();

        services.AddSingleton<IAddContacts, AddContacts>();
        services.AddSingleton<IMenuFactory, MenuFactory>();

        // Registrering Helpers
        services.AddSingleton<IIdHelpers, IdHelpers>();
        services.AddSingleton<IInputValidationHelper, InputValidationHelper>();

        // Registering the MenuService using Concrete class and mapping it to the interfaces using lambda expressions
        services.AddSingleton<MenuService>();
        services.AddSingleton<IMenuCreateService>(sp => sp.GetRequiredService<MenuService>());
        services.AddSingleton<IGetMenuService>(sp => sp.GetRequiredService<MenuService>());

        // Registering the MenuDisplayHelper using Concrete class and mapping
        services.AddSingleton<IMenuNavigationService, MenuNavigationService>();
        services.AddSingleton<IMenuDisplayHelper, MenuDisplayHelper>();

        // Registering the ContactFactory using Concrete class and mapping
        services.AddSingleton<ContactService>();
        services.AddSingleton<IContactCreateService>(sp => sp.GetRequiredService<ContactService>());
        services.AddSingleton<IContactGetService>(sp => sp.GetRequiredService<ContactService>());
        services.AddSingleton<IContactFactory, ContactFactory>();

        // Registering the File using Concrete class and mapping
        services.AddSingleton<FileService>();
        services.AddSingleton<IFileService>(sp => sp.GetRequiredService<FileService>());
        services.AddSingleton<IFileServerDataHandler>(sp => sp.GetRequiredService<FileService>());
        services.AddSingleton<IFileServerAdministration>(sp => sp.GetRequiredService<FileService>());
    }
}